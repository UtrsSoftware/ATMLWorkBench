// ------------------------------------------------------------------------------
//  <auto-generated>
//    Generated by Xsd2Code++. Version 4.0.0.283
//    <NameSpace>ATMLCommonLibrary.model.equipment</NameSpace><Collection>List</Collection><codeType>CSharp</codeType><EnableDataBinding>False</EnableDataBinding><GenerateCloneMethod>False</GenerateCloneMethod><GenerateDataContracts>False</GenerateDataContracts><CodeBaseTag>Net40</CodeBaseTag><InitializeFields>None</InitializeFields><GenerateUnusedComplexTypes>True</GenerateUnusedComplexTypes><GenerateUnusedSimpleTypes>True</GenerateUnusedSimpleTypes><GenerateXMLAttributes>True</GenerateXMLAttributes><OrderXMLAttrib>True</OrderXMLAttrib><EnableLazyLoading>False</EnableLazyLoading><VirtualProp>False</VirtualProp><PascalCase>False</PascalCase><AutomaticProperties>False</AutomaticProperties><PropNameSpecified>Default</PropNameSpecified><PrivateFieldName>StartWithUnderscore</PrivateFieldName><TrackingChangesEnable>False</TrackingChangesEnable><GenTrackingClasses>False</GenTrackingClasses><HidePrivateFieldInIDE>True</HidePrivateFieldInIDE><EnableSummaryComment>True</EnableSummaryComment><EnableExternalSchemasCache>False</EnableExternalSchemasCache><EnableDebug>False</EnableDebug><EnableWarn>False</EnableWarn><ExcludeImportedTypes>True</ExcludeImportedTypes><ExpandNesteadAttributeGroup>False</ExpandNesteadAttributeGroup><CleanupCode>True</CleanupCode><EnableXmlSerialization>True</EnableXmlSerialization><SerializeMethodName>Serialize</SerializeMethodName><DeserializeMethodName>Deserialize</DeserializeMethodName><SaveToFileMethodName>SaveToFile</SaveToFileMethodName><LoadFromFileMethodName>LoadFromFile</LoadFromFileMethodName><EnableEncoding>False</EnableEncoding><EnableXMLIndent>False</EnableXMLIndent><Encoder>UTF8</Encoder><Serializer>XmlSerializer</Serializer><GenerateShouldSerialize>True</GenerateShouldSerialize><BaseClassName>EntityBase</BaseClassName><UseBaseClass>False</UseBaseClass><GenBaseClass>False</GenBaseClass><CustomUsings>ATMLCommonLibrary.model.common</CustomUsings>
//  </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable
namespace ATMLModelLibrary.model.equipment
{
    using System;
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System.Collections;
    using System.Xml.Schema;
    using System.ComponentModel;
    using ATMLModelLibrary.model.common;
    using System.IO;
    using System.Text;
    using System.Collections.Generic;


    /// <summary>
    /// Instruments may be represented as individual entities or as logical groups that represent an over-all source, sensor, or load capability.
    /// Figure 1 illustrates the XML types inherited and the XML types (both simple and complex) that shall be defined in this standard, which together comprise the InstrumentDescription.
    /// Within Figure 1, solid lined boxes indicate that the XML element shall be required, whereas dotted lined boxes indicate that the XML element may be used. The referenced subclause identifies where the definition of the element is located within this standard or IEEE Std 1671.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    [XmlRootAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription", IsNullable = false)]
    public partial class InstrumentDescription : HardwareItemDescription
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private List<Bus> _buses;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private List<NamedValue> _powerOnDefaults;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private List<Path> _paths;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private Specifications _specifications;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private List<Resource> _resources;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private Switching _switching;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private Capabilities _capabilities;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private InstrumentDescriptionType _type;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private string _uuid;

        private static XmlSerializer serializer;

        /// <summary>
        /// When present, the InstrumentDescription/Buses child element shall document the instrument’s communication bus (or buses).
        /// </summary>
        [XmlArrayAttribute(Order = 0)]
        [XmlArrayItemAttribute(IsNullable = false)]
        public List<Bus> Buses
        {
            get
            {
                return _buses;
            }
            set
            {
                _buses = value;
            }
        }

        /// <summary>
        /// When present, the InstrumentDescription/PowerOnDefaults child element shall document the instrument’s power-on default state.
        /// </summary>
        [XmlArrayAttribute(Order = 1)]
        [XmlArrayItemAttribute("Default", IsNullable = false)]
        public List<NamedValue> PowerOnDefaults
        {
            get
            {
                return _powerOnDefaults;
            }
            set
            {
                _powerOnDefaults = value;
            }
        }

        /// <summary>
        /// The InstrumentDescription/Paths child element shall identify the characteristics of the signal paths through the Instrument and interface hardware
        /// </summary>
        [XmlArrayAttribute(Order = 2)]
        [XmlArrayItemAttribute(Namespace = "urn:IEEE-1671:2010:TestEquipment", IsNullable = false)]
        public List<Path> Paths
        {
            get
            {
                return _paths;
            }
            set
            {
                _paths = value;
            }
        }

        /// <summary>
        /// When present, the InstrumentDescription/Specifications child element shall document the specifications of an instrument.
        /// </summary>
        [XmlElementAttribute(Order = 3)]
        public Specifications Specifications
        {
            get
            {
                return _specifications;
            }
            set
            {
                _specifications = value;
            }
        }

        /// <summary>
        /// When present, the InstrumentDescription/Resources child element shall document the physical entities within the instrument that provide source, sensor, or load capabilities.
        /// </summary>
        [XmlArrayAttribute(Order = 4)]
        [XmlArrayItemAttribute(Namespace = "urn:IEEE-1671:2010:HardwareCommon", IsNullable = false)]
        public List<Resource> Resources
        {
            get
            {
                return _resources;
            }
            set
            {
                _resources = value;
            }
        }

        /// <summary>
        /// When present, the InstrumentDescription/Switching child element shall document a signal switching instrument or a source, sensor, or load instrument that contains switching. These include: general purpose, matrix, multiplexing, coaxial, microwave, optical, and cross point switching.
        /// </summary>
        [XmlElementAttribute(Order = 5)]
        public Switching Switching
        {
            get
            {
                return _switching;
            }
            set
            {
                _switching = value;
            }
        }

        /// <summary>
        /// When present, the InstrumentDescription/Capabilities child element shall document the types of signals that an instrument can produce (or measure) and the uncertainties involved in either generating or producing the signals.
        /// This may be the ability to measure voltage, current, or resistance [such as a digital multi-meter (DMM)] may provide) or the ability to create and provide a clock frequency [such as a synthetic local oscillator (LO) may provide] within an SI subsystem.
        /// </summary>
        [XmlElementAttribute(Order = 6)]
        public Capabilities Capabilities
        {
            get
            {
                return _capabilities;
            }
            set
            {
                _capabilities = value;
            }
        }

        /// <summary>
        /// An enumeration used to identify whether the InstrumentDescription is describing an “Instrument,” “Module,” or instrument “Option.”
        /// </summary>
        [XmlAttribute]
        public InstrumentDescriptionType type
        {
            get
            {
                return _type;
            }
            set
            {
                _type = value;
            }
        }

        [XmlAttribute]
        public string uuid
        {
            get
            {
                return _uuid;
            }
            set
            {
                _uuid = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(InstrumentDescription));
                }
                return serializer;
            }
        }

        /// <summary>
        /// Test whether Buses should be serialized
        /// </summary>
        public virtual bool ShouldSerializeBuses()
        {
            return Buses != null && Buses.Count > 0;
        }

        /// <summary>
        /// Test whether PowerOnDefaults should be serialized
        /// </summary>
        public virtual bool ShouldSerializePowerOnDefaults()
        {
            return PowerOnDefaults != null && PowerOnDefaults.Count > 0;
        }

        /// <summary>
        /// Test whether Paths should be serialized
        /// </summary>
        public virtual bool ShouldSerializePaths()
        {
            return Paths != null && Paths.Count > 0;
        }

        /// <summary>
        /// Test whether Resources should be serialized
        /// </summary>
        public virtual bool ShouldSerializeResources()
        {
            return Resources != null && Resources.Count > 0;
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current InstrumentDescription object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an InstrumentDescription object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output InstrumentDescription object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out InstrumentDescription obj, out Exception exception)
        {
            exception = null;
            obj = default(InstrumentDescription);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out InstrumentDescription obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static InstrumentDescription Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((InstrumentDescription)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static InstrumentDescription Deserialize(Stream s)
        {
            return ((InstrumentDescription)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current InstrumentDescription object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an InstrumentDescription object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output InstrumentDescription object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out InstrumentDescription obj, out Exception exception)
        {
            exception = null;
            obj = default(InstrumentDescription);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out InstrumentDescription obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static InstrumentDescription LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// When present, the Bus complex type shall identify the bus used to communicate with the instrument.
    /// </summary>
    [XmlIncludeAttribute(typeof(PCI))]
    [XmlIncludeAttribute(typeof(PXI))]
    [XmlIncludeAttribute(typeof(PXIe))]
    [XmlIncludeAttribute(typeof(PCIe))]
    [XmlIncludeAttribute(typeof(IEEE1394))]
    [XmlIncludeAttribute(typeof(USB))]
    [XmlIncludeAttribute(typeof(EIA232))]
    [XmlIncludeAttribute(typeof(Ethernet))]
    [XmlIncludeAttribute(typeof(LXI))]
    [XmlIncludeAttribute(typeof(VME))]
    [XmlIncludeAttribute(typeof(IEEE488))]
    [XmlIncludeAttribute(typeof(VXI))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public abstract partial class Bus
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private string _defaultAddress;

        private static XmlSerializer serializer;

        /// <summary>
        /// A string that permits the instrument’s default address to be indicated. Example: “255” (for VXI dynamic addressing)
        /// </summary>
        [XmlAttribute]
        public string defaultAddress
        {
            get
            {
                return _defaultAddress;
            }
            set
            {
                _defaultAddress = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(Bus));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current Bus object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an Bus object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output Bus object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out Bus obj, out Exception exception)
        {
            exception = null;
            obj = default(Bus);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out Bus obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public static Bus Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((Bus)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static Bus Deserialize(Stream s)
        {
            return ((Bus)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current Bus object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an Bus object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output Bus object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out Bus obj, out Exception exception)
        {
            exception = null;
            obj = default(Bus);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out Bus obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public static Bus LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// Used by child elements: PXI/DynamicCurrent, PXI/PeakCurrent
    /// When present, the PXIBackplaneVoltages complex type shall store the amount of current (expressed in amperes) consumed by or provided by the device.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class PXIBackplaneVoltages
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _plus_5;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _plus_33;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _plus_12;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _minus_12;

        private static XmlSerializer serializer;

        /// <summary>
        /// The amount of current on the +5 line. A positive value means the device provides current. A negative value means the device consumes current. Example: “–0.5”
        /// </summary>
        [XmlAttribute]
        public double plus_5
        {
            get
            {
                return _plus_5;
            }
            set
            {
                _plus_5 = value;
            }
        }

        [XmlAttributeAttribute("plus_3.3")]
        public double plus_33
        {
            get
            {
                return _plus_33;
            }
            set
            {
                _plus_33 = value;
            }
        }

        /// <summary>
        /// The amount of current on the +12 line. A positive value means the device provides current. A negative value means the device consumes current. Example: “–0.5”
        /// </summary>
        [XmlAttribute]
        public double plus_12
        {
            get
            {
                return _plus_12;
            }
            set
            {
                _plus_12 = value;
            }
        }

        /// <summary>
        /// The amount of current on the –12 line. A positive value means the device provides current. A negative value means the device consumes current. Example: “–0.5”
        /// </summary>
        [XmlAttribute]
        public double minus_12
        {
            get
            {
                return _minus_12;
            }
            set
            {
                _minus_12 = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(PXIBackplaneVoltages));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current PXIBackplaneVoltages object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an PXIBackplaneVoltages object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output PXIBackplaneVoltages object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out PXIBackplaneVoltages obj, out Exception exception)
        {
            exception = null;
            obj = default(PXIBackplaneVoltages);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out PXIBackplaneVoltages obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public static PXIBackplaneVoltages Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((PXIBackplaneVoltages)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static PXIBackplaneVoltages Deserialize(Stream s)
        {
            return ((PXIBackplaneVoltages)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current PXIBackplaneVoltages object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an PXIBackplaneVoltages object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output PXIBackplaneVoltages object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out PXIBackplaneVoltages obj, out Exception exception)
        {
            exception = null;
            obj = default(PXIBackplaneVoltages);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out PXIBackplaneVoltages obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public static PXIBackplaneVoltages LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// When present, the SupportedClockSources complex type shall identify which clock sources the device will accept. Each type (backplane, external and internal) shall be indicated as either a “yes” or “no,” allowing every combination from “none” to “all” to be represented. Example: An instrument that may only be clocked from an external source would have the backplane and internal attributes set to “0” (no) and the external attribute set to “1” (yes).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class SupportedClockSources
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private bool _internal;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private bool _external;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private bool _backplane;

        private static XmlSerializer serializer;

        /// <summary>
        /// Whether or not the device will accept an internal clock. Example: “1” = “yes”
        /// </summary>
        [XmlAttribute]
        public bool @internal
        {
            get
            {
                return _internal;
            }
            set
            {
                _internal = value;
            }
        }

        /// <summary>
        /// Whether or not the device will accept an external clock. Example: “0” = “no”
        /// </summary>
        [XmlAttribute]
        public bool external
        {
            get
            {
                return _external;
            }
            set
            {
                _external = value;
            }
        }

        /// <summary>
        /// Whether or not the device will accept a backplane clock. Example: “1” = “yes”
        /// </summary>
        [XmlAttribute]
        public bool backplane
        {
            get
            {
                return _backplane;
            }
            set
            {
                _backplane = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(SupportedClockSources));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current SupportedClockSources object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an SupportedClockSources object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output SupportedClockSources object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out SupportedClockSources obj, out Exception exception)
        {
            exception = null;
            obj = default(SupportedClockSources);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out SupportedClockSources obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public static SupportedClockSources Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((SupportedClockSources)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static SupportedClockSources Deserialize(Stream s)
        {
            return ((SupportedClockSources)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current SupportedClockSources object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an SupportedClockSources object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output SupportedClockSources object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out SupportedClockSources obj, out Exception exception)
        {
            exception = null;
            obj = default(SupportedClockSources);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out SupportedClockSources obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public static SupportedClockSources LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// Used by child elements: VXI/ECLTrigger, VXI/TTLTrigger
    /// When present, the VXITriggerLines complex type shall identify the number of concurrent trigger lines either being outputted by, or sensed by, the VXI instrument. The number of concurrent trigger lines shall be expressed as an integer number.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class VXITriggerLines
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int? _source;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int? _sense;

        private static XmlSerializer serializer;

        /// <summary>
        /// The number of VXI triggers that may concurrently generate outputs. Allowable values are 0 or greater.
        /// </summary>
        [XmlAttribute]
        public int source
        {
            get
            {
                if (_source.HasValue)
                {
                    return _source.Value;
                }
                else
                {
                    return default(int);
                }
            }
            set
            {
                _source = value;
            }
        }

        [XmlIgnore]
        public bool sourceSpecified
        {
            get
            {
                return _source.HasValue;
            }
            set
            {
                if (value == false)
                {
                    _source = null;
                }
            }
        }

        /// <summary>
        /// The number of VXI triggers that may concurrently receive inputs. Allowable values are 0 or greater.
        /// </summary>
        [XmlAttribute]
        public int sense
        {
            get
            {
                if (_sense.HasValue)
                {
                    return _sense.Value;
                }
                else
                {
                    return default(int);
                }
            }
            set
            {
                _sense = value;
            }
        }

        [XmlIgnore]
        public bool senseSpecified
        {
            get
            {
                return _sense.HasValue;
            }
            set
            {
                if (value == false)
                {
                    _sense = null;
                }
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(VXITriggerLines));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current VXITriggerLines object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an VXITriggerLines object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output VXITriggerLines object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out VXITriggerLines obj, out Exception exception)
        {
            exception = null;
            obj = default(VXITriggerLines);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out VXITriggerLines obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public static VXITriggerLines Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((VXITriggerLines)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static VXITriggerLines Deserialize(Stream s)
        {
            return ((VXITriggerLines)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current VXITriggerLines object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an VXITriggerLines object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output VXITriggerLines object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out VXITriggerLines obj, out Exception exception)
        {
            exception = null;
            obj = default(VXITriggerLines);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out VXITriggerLines obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public static VXITriggerLines LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// Used by child elements: VXI/DynamicCurrent, VXI/PeakCurrent
    /// When present, the VXIBackplaneVoltages complex type shall store the amount of electrical current sunk by the VXI instrument on each of the eight discrete VXI backplane voltages. The electrical current shall be expressed in amperes.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class VXIBackplaneVoltages
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _plus_12;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _plus_24;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _plus_5_standby;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _plus_5;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _minus_12;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _minus_24;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _minus_2;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _minus_52;

        private static XmlSerializer serializer;

        /// <summary>
        /// The amount of current on the +12 V line. A positive value means the device provides current. A negative value means the device consumes current. Example: “–0.5”
        /// </summary>
        [XmlAttribute]
        public double plus_12
        {
            get
            {
                return _plus_12;
            }
            set
            {
                _plus_12 = value;
            }
        }

        /// <summary>
        /// The amount of current on the +24 V line. A positive value means the device provides current. A negative value means the device consumes current. Example: “–0.5”
        /// </summary>
        [XmlAttribute]
        public double plus_24
        {
            get
            {
                return _plus_24;
            }
            set
            {
                _plus_24 = value;
            }
        }

        /// <summary>
        /// The amount of current on the +5 V standby line. A positive value means the device provides current. A negative value means the device consumes current. Example: “–0.5”
        /// </summary>
        [XmlAttribute]
        public double plus_5_standby
        {
            get
            {
                return _plus_5_standby;
            }
            set
            {
                _plus_5_standby = value;
            }
        }

        /// <summary>
        /// The amount of current on the +5 V line. A positive value means the device provides current. A negative value means the device consumes current. Example: “–0.5”
        /// </summary>
        [XmlAttribute]
        public double plus_5
        {
            get
            {
                return _plus_5;
            }
            set
            {
                _plus_5 = value;
            }
        }

        /// <summary>
        /// The amount of current on the –12 V line. A positive value means the device provides current. A negative value means the device consumes current. Example: “–0.5”
        /// </summary>
        [XmlAttribute]
        public double minus_12
        {
            get
            {
                return _minus_12;
            }
            set
            {
                _minus_12 = value;
            }
        }

        /// <summary>
        /// The amount of current on the –24 V line. A positive value means the device provides current. A negative value means the device consumes current. Example: “–0.5”
        /// </summary>
        [XmlAttribute]
        public double minus_24
        {
            get
            {
                return _minus_24;
            }
            set
            {
                _minus_24 = value;
            }
        }

        /// <summary>
        /// The amount of current on the –2 V line. A positive value means the device provides current. A negative value means the device consumes current. Example: “–0.5”
        /// </summary>
        [XmlAttribute]
        public double minus_2
        {
            get
            {
                return _minus_2;
            }
            set
            {
                _minus_2 = value;
            }
        }

        [XmlAttributeAttribute("minus_5.2")]
        public double minus_52
        {
            get
            {
                return _minus_52;
            }
            set
            {
                _minus_52 = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(VXIBackplaneVoltages));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current VXIBackplaneVoltages object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an VXIBackplaneVoltages object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output VXIBackplaneVoltages object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out VXIBackplaneVoltages obj, out Exception exception)
        {
            exception = null;
            obj = default(VXIBackplaneVoltages);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out VXIBackplaneVoltages obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public static VXIBackplaneVoltages Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((VXIBackplaneVoltages)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static VXIBackplaneVoltages Deserialize(Stream s)
        {
            return ((VXIBackplaneVoltages)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current VXIBackplaneVoltages object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an VXIBackplaneVoltages object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output VXIBackplaneVoltages object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out VXIBackplaneVoltages obj, out Exception exception)
        {
            exception = null;
            obj = default(VXIBackplaneVoltages);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out VXIBackplaneVoltages obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public static VXIBackplaneVoltages LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// When present, the PCI complex type shall identify that there is a PCI conformant interface to the instrument. See Conventional PCI 3.0 [B2]. Should there be more than one manufacturer, there shall be more than on instance document (one per manufacturer).
    /// </summary>
    [XmlIncludeAttribute(typeof(PXI))]
    [XmlIncludeAttribute(typeof(PXIe))]
    [XmlIncludeAttribute(typeof(PCIe))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class PCI : Bus
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private string _vendorID;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private string _deviceID;

        private static XmlSerializer serializer;

        /// <summary>
        /// The identification of the manufacturer of the instrument. Valid vendor IDs are allocated by the PCI Special Interest Group (PCI-SIG) to ensure uniqueness.
        /// </summary>
        [XmlAttribute]
        public string vendorID
        {
            get
            {
                return _vendorID;
            }
            set
            {
                _vendorID = value;
            }
        }

        /// <summary>
        /// The identification of the particular instrument. This identifier (ID) is allocated by the vendor.
        /// </summary>
        [XmlAttribute]
        public string deviceID
        {
            get
            {
                return _deviceID;
            }
            set
            {
                _deviceID = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(PCI));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current PCI object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an PCI object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output PCI object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out PCI obj, out Exception exception)
        {
            exception = null;
            obj = default(PCI);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out PCI obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static PCI Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((PCI)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static PCI Deserialize(Stream s)
        {
            return ((PCI)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current PCI object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an PCI object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output PCI object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out PCI obj, out Exception exception)
        {
            exception = null;
            obj = default(PCI);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out PCI obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static PCI LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// Used by complex type: PXIe
    /// When present, the PXI complex type shall identify that there is a PXI conformant interface to the instrument. See PXI-1 [B20] and PXI-2 [B21].
    /// </summary>
    [XmlIncludeAttribute(typeof(PXIe))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class PXI : PCI
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private PXIBackplaneVoltages _dynamicCurrent;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private PXIBackplaneVoltages _peakCurrent;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private SupportedClockSources _supportedClockSources;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private DeviceCategory _deviceCategory;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int _slots;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private PXISlotSize _slotSize;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _slotWeigth;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int _memorySize;

        private static XmlSerializer serializer;

        /// <summary>
        /// When present, the PXI/DynamicCurrent child element shall document the dynamic current (expressed in amperes) consumed or generated on each of the discrete PXI backplane voltages.
        /// </summary>
        [XmlElementAttribute(Order = 0)]
        public PXIBackplaneVoltages DynamicCurrent
        {
            get
            {
                return _dynamicCurrent;
            }
            set
            {
                _dynamicCurrent = value;
            }
        }

        /// <summary>
        /// When present, the PXI/PeakCurrent child element shall document the peak current (expressed in amperes) consumed or generated on each of the discrete PXI backplane voltages.
        /// </summary>
        [XmlElementAttribute(Order = 1)]
        public PXIBackplaneVoltages PeakCurrent
        {
            get
            {
                return _peakCurrent;
            }
            set
            {
                _peakCurrent = value;
            }
        }

        /// <summary>
        /// When present, the PXI/SupportedClockSources child element shall document the clock sources the instrument supports.
        /// </summary>
        [XmlElementAttribute(Order = 2)]
        public SupportedClockSources SupportedClockSources
        {
            get
            {
                return _supportedClockSources;
            }
            set
            {
                _supportedClockSources = value;
            }
        }

        [XmlAttribute]
        public DeviceCategory deviceCategory
        {
            get
            {
                return _deviceCategory;
            }
            set
            {
                _deviceCategory = value;
            }
        }

        /// <summary>
        /// The number of PXI slots provided or consumed by this device.
        /// </summary>
        [XmlAttribute]
        public int slots
        {
            get
            {
                return _slots;
            }
            set
            {
                _slots = value;
            }
        }

        /// <summary>
        /// A string specifying which of the defined sizes this PXI component supports. The string shall be one of the following: 3U, 6U.
        /// </summary>
        [XmlAttribute]
        public PXISlotSize slotSize
        {
            get
            {
                return _slotSize;
            }
            set
            {
                _slotSize = value;
            }
        }

        /// <summary>
        /// For a PXI module, this is a negative floating point number representing the weight of the module in kilogram per slot occupied.
        /// For a PXI mainframe, this is a positive floating point number representing the weight of the mainframe in kilogram per slot provided.
        /// </summary>
        [XmlAttribute]
        public double slotWeigth
        {
            get
            {
                return _slotWeigth;
            }
            set
            {
                _slotWeigth = value;
            }
        }

        [XmlAttribute]
        public int memorySize
        {
            get
            {
                return _memorySize;
            }
            set
            {
                _memorySize = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(PXI));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current PXI object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an PXI object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output PXI object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out PXI obj, out Exception exception)
        {
            exception = null;
            obj = default(PXI);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out PXI obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static PXI Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((PXI)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static PXI Deserialize(Stream s)
        {
            return ((PXI)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current PXI object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an PXI object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output PXI object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out PXI obj, out Exception exception)
        {
            exception = null;
            obj = default(PXI);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out PXI obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static PXI LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// Type: restriction of xs:string
    /// Used by child elements: VXI/@deviceCategory, PXI/@deviceCategory
    /// Permits the instrument category to be identified, as one of the following: “InstrumentModule,” “Slot0Device,” or “Mainframe.”
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public enum DeviceCategory
    {

        InstrumentModule,

        Slot0Device,

        Mainframe,
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [XmlTypeAttribute(AnonymousType = true, Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public enum PXISlotSize
    {

        [XmlEnumAttribute("3U")]
        Item3U,

        [XmlEnumAttribute("6U")]
        Item6U,
    }

    /// <summary>
    /// When present, the PXIe complex type shall identify that there is a PXI Express conformant interface to the instrument. See PXI-5 [B22] and PXI-6 [B23].
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class PXIe : PXI
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int _numberOfLanes;

        private static XmlSerializer serializer;

        /// <summary>
        /// The integer number of lanes the instrument supports. Lanes are point-to-point full duplex serial links. Each PCIe slot carries either 1, 2, 4, 8, 16, or 32 lanes of data between the motherboard and the card. Lane counts are written with an x prefix (e.g., x1 for a single-lane card and x16 for a 16-lane card).
        /// </summary>
        [XmlAttribute]
        public int numberOfLanes
        {
            get
            {
                return _numberOfLanes;
            }
            set
            {
                _numberOfLanes = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(PXIe));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current PXIe object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an PXIe object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output PXIe object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out PXIe obj, out Exception exception)
        {
            exception = null;
            obj = default(PXIe);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out PXIe obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static PXIe Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((PXIe)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static PXIe Deserialize(Stream s)
        {
            return ((PXIe)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current PXIe object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an PXIe object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output PXIe object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out PXIe obj, out Exception exception)
        {
            exception = null;
            obj = default(PXIe);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out PXIe obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static PXIe LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// When present, the PCIe complex type shall identify that there is a PCIe conformant interface to the instrument. See PCIe Base Specification 1.1 [B19].
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class PCIe : PCI
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int _numberOfLanes;

        private static XmlSerializer serializer;

        /// <summary>
        /// The integer number of lanes the instrument supports. Lanes are point-to-point full duplex serial links. Each PCIe slot carries either 1, 2, 4, 8, 16, or 32 lanes of data between the motherboard and the card. Lane counts are written with an x prefix (e.g., x1 for a single-lane card and x16 for a 16-lane card).
        /// </summary>
        [XmlAttribute]
        public int numberOfLanes
        {
            get
            {
                return _numberOfLanes;
            }
            set
            {
                _numberOfLanes = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(PCIe));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current PCIe object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an PCIe object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output PCIe object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out PCIe obj, out Exception exception)
        {
            exception = null;
            obj = default(PCIe);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out PCIe obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static PCIe Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((PCIe)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static PCIe Deserialize(Stream s)
        {
            return ((PCIe)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current PCIe object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an PCIe object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output PCIe object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out PCIe obj, out Exception exception)
        {
            exception = null;
            obj = default(PCIe);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out PCIe obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static PCIe LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(TypeName = "IEEE-1394", Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class IEEE1394 : Bus
    {

        private static XmlSerializer serializer;

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(IEEE1394));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current IEEE1394 object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an IEEE1394 object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output IEEE1394 object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out IEEE1394 obj, out Exception exception)
        {
            exception = null;
            obj = default(IEEE1394);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out IEEE1394 obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static IEEE1394 Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((IEEE1394)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static IEEE1394 Deserialize(Stream s)
        {
            return ((IEEE1394)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current IEEE1394 object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an IEEE1394 object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output IEEE1394 object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out IEEE1394 obj, out Exception exception)
        {
            exception = null;
            obj = default(IEEE1394);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out IEEE1394 obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static IEEE1394 LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// When present, the USB complex type shall identify that there is a USB conformant interface to the instrument. See Universal Serial Bus [B24].
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class USB : Bus
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private VersionIdentifier _version;

        private static XmlSerializer serializer;

        /// <summary>
        /// When present, the USB/Version child element shall identify the version of USB supported.
        /// </summary>
        [XmlElementAttribute(Order = 0)]
        public VersionIdentifier Version
        {
            get
            {
                return _version;
            }
            set
            {
                _version = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(USB));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current USB object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an USB object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output USB object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out USB obj, out Exception exception)
        {
            exception = null;
            obj = default(USB);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out USB obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static USB Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((USB)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static USB Deserialize(Stream s)
        {
            return ((USB)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current USB object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an USB object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output USB object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out USB obj, out Exception exception)
        {
            exception = null;
            obj = default(USB);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out USB obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static USB LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(TypeName = "EIA-232", Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class EIA232 : Bus
    {

        private static XmlSerializer serializer;

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(EIA232));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current EIA232 object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an EIA232 object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output EIA232 object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out EIA232 obj, out Exception exception)
        {
            exception = null;
            obj = default(EIA232);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out EIA232 obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static EIA232 Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((EIA232)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static EIA232 Deserialize(Stream s)
        {
            return ((EIA232)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current EIA232 object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an EIA232 object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output EIA232 object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out EIA232 obj, out Exception exception)
        {
            exception = null;
            obj = default(EIA232);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out EIA232 obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static EIA232 LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// Used by complex type: LXI
    /// When present, the Ethernet complex type shall identify that there is an Ethernet interface to the instrument. See IEEE Std 802.3™-2005 [B7].
    /// </summary>
    [XmlIncludeAttribute(typeof(LXI))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class Ethernet : Bus
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private bool _supportsDHCP;

        private static XmlSerializer serializer;

        /// <summary>
        /// A Boolean “yes” or “no” indication as to whether the instrument’s Ethernet interface supports the Dynamic Host Configuration Protocol (DHCPv4 Specification RFC 4361 [B3])
        /// </summary>
        [XmlAttribute]
        public bool supportsDHCP
        {
            get
            {
                return _supportsDHCP;
            }
            set
            {
                _supportsDHCP = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(Ethernet));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current Ethernet object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an Ethernet object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output Ethernet object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out Ethernet obj, out Exception exception)
        {
            exception = null;
            obj = default(Ethernet);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out Ethernet obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static Ethernet Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((Ethernet)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static Ethernet Deserialize(Stream s)
        {
            return ((Ethernet)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current Ethernet object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an Ethernet object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output Ethernet object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out Ethernet obj, out Exception exception)
        {
            exception = null;
            obj = default(Ethernet);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out Ethernet obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static Ethernet LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// When present, the LXI complex type shall identify that there is an LXI conformant Ethernet interface to the instrument. See LXI Standard [B16].
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class LXI : Ethernet
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private string _lXIVersion;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private LXIClass _class;

        private static XmlSerializer serializer;

        /// <summary>
        /// A string that permits the LXI version to be indicated. Example: “1.2.01”
        /// </summary>
        [XmlAttribute]
        public string LXIVersion
        {
            get
            {
                return _lXIVersion;
            }
            set
            {
                _lXIVersion = value;
            }
        }

        /// <summary>
        /// The LXI class. The allowable classes are: A, B, or C.
        /// </summary>
        [XmlAttribute]
        public LXIClass @class
        {
            get
            {
                return _class;
            }
            set
            {
                _class = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(LXI));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current LXI object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an LXI object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output LXI object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out LXI obj, out Exception exception)
        {
            exception = null;
            obj = default(LXI);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out LXI obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static LXI Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((LXI)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static LXI Deserialize(Stream s)
        {
            return ((LXI)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current LXI object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an LXI object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output LXI object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out LXI obj, out Exception exception)
        {
            exception = null;
            obj = default(LXI);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out LXI obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static LXI LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [XmlTypeAttribute(AnonymousType = true, Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public enum LXIClass
    {

        A,

        B,

        C,
    }

    /// <summary>
    /// When present, the VME complex type shall identify that there is an IEEE 1014™ (VME) conformant interface (either 32-bit or 64-bit VME) to the instrument. See IEEE Std 1014-1987 [B8].
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class VME : Bus
    {

        private static XmlSerializer serializer;

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(VME));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current VME object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an VME object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output VME object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out VME obj, out Exception exception)
        {
            exception = null;
            obj = default(VME);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out VME obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static VME Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((VME)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static VME Deserialize(Stream s)
        {
            return ((VME)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current VME object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an VME object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output VME object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out VME obj, out Exception exception)
        {
            exception = null;
            obj = default(VME);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out VME obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static VME LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(TypeName = "IEEE-488", Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class IEEE488 : Bus
    {

        private static XmlSerializer serializer;

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(IEEE488));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current IEEE488 object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an IEEE488 object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output IEEE488 object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out IEEE488 obj, out Exception exception)
        {
            exception = null;
            obj = default(IEEE488);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out IEEE488 obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static IEEE488 Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((IEEE488)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static IEEE488 Deserialize(Stream s)
        {
            return ((IEEE488)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current IEEE488 object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an IEEE488 object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output IEEE488 object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out IEEE488 obj, out Exception exception)
        {
            exception = null;
            obj = default(IEEE488);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out IEEE488 obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static IEEE488 LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// When present, the VXI complex type shall identify that there is an IEEE 1155™ conformant interface to the instrument. See IEEE Std 1155-1992 [B10].
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class VXI : Bus
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private VXIBackplaneVoltages _dynamicCurrent;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private VXIBackplaneVoltages _peakCurrent;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private VXITriggerLines _eCLTrigger;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private VXITriggerLines _tTLTrigger;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private VXIKeying _keying;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private VXIModuleCooling _moduleCooling;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private SupportedClockSources _supportedClockSources;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private VXIAddressSpace _addressSpace;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private VXIDeviceClass _deviceClass;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private DeviceCategory _deviceCategory;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private bool _dynamicallyConfigured;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int _interruptLines;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private string _manufacturerID;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private string _modelCode;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private string _requiredMemory;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private VXISlotSize _slotSize;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _slotWeight;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int _slots;

        private static XmlSerializer serializer;

        /// <summary>
        /// When present, the VXI/DynamicCurrent child element shall identify the dynamic electrical current requirements of the VXI instrument for each of the discrete eight VXI backplane voltages. The current shall be expressed in amperes.
        /// </summary>
        [XmlElementAttribute(Order = 0)]
        public VXIBackplaneVoltages DynamicCurrent
        {
            get
            {
                return _dynamicCurrent;
            }
            set
            {
                _dynamicCurrent = value;
            }
        }

        /// <summary>
        /// When present, the VXI/PeakCurrent child element shall identify the peak electrical current requirements of the VXI instrument for each of the eight discrete VXI backplane voltages. The electrical current shall be expressed in amperes.
        /// </summary>
        [XmlElementAttribute(Order = 1)]
        public VXIBackplaneVoltages PeakCurrent
        {
            get
            {
                return _peakCurrent;
            }
            set
            {
                _peakCurrent = value;
            }
        }

        /// <summary>
        /// When present, the VXI/ECLTrigger child element shall identify the number of concurrent ECL trigger lines (ECLTRIG0-1) either being outputted by, or sensed by, the VXI instrument. The number of concurrent trigger lines shall be expressed as an integer number.
        /// </summary>
        [XmlElementAttribute(Order = 2)]
        public VXITriggerLines ECLTrigger
        {
            get
            {
                return _eCLTrigger;
            }
            set
            {
                _eCLTrigger = value;
            }
        }

        /// <summary>
        /// When present, the VXI/TTLTrigger child element shall identify the number of concurrent TTL trigger lines (TTLTRIG0-7) either being outputted by, or sensed by, the VXI instrument. The number of concurrent trigger lines shall be expressed as an integer number.
        /// </summary>
        [XmlElementAttribute(Order = 3)]
        public VXITriggerLines TTLTrigger
        {
            get
            {
                return _tTLTrigger;
            }
            set
            {
                _tTLTrigger = value;
            }
        }

        /// <summary>
        /// When present, the VXI/Keying child element shall identify the VXI local bus lockout key details utilized by the instrument. Keying Class 1 through 6 shall be as defined by VXI-1, B.7.2.6 [B25]. Keying Class 7 shall be defined as “no local bus,” keying class 8 shall be defined as “sensor ±16V,” and keying class 9 shall be defined as “sensor ±42V.”
        /// </summary>
        [XmlElementAttribute(Order = 4)]
        public VXIKeying Keying
        {
            get
            {
                return _keying;
            }
            set
            {
                _keying = value;
            }
        }

        /// <summary>
        /// When present, the VXI/ModuleCooling child element shall identify the VXI instruments air-flow and back-pressure cooling characteristics.
        /// </summary>
        [XmlElementAttribute(Order = 5)]
        public VXIModuleCooling ModuleCooling
        {
            get
            {
                return _moduleCooling;
            }
            set
            {
                _moduleCooling = value;
            }
        }

        /// <summary>
        /// When present, the VXI/SupportedClockSources child element shall document the clock sources the instrument supports.
        /// </summary>
        [XmlElementAttribute(Order = 6)]
        public SupportedClockSources SupportedClockSources
        {
            get
            {
                return _supportedClockSources;
            }
            set
            {
                _supportedClockSources = value;
            }
        }

        /// <summary>
        /// Identifies the type of VXI address space needed by the instrument or module in addition to A16.
        /// </summary>
        [XmlAttribute]
        public VXIAddressSpace addressSpace
        {
            get
            {
                return _addressSpace;
            }
            set
            {
                _addressSpace = value;
            }
        }

        [XmlAttribute]
        public VXIDeviceClass deviceClass
        {
            get
            {
                return _deviceClass;
            }
            set
            {
                _deviceClass = value;
            }
        }

        [XmlAttribute]
        public DeviceCategory deviceCategory
        {
            get
            {
                return _deviceCategory;
            }
            set
            {
                _deviceCategory = value;
            }
        }

        [XmlAttribute]
        public bool dynamicallyConfigured
        {
            get
            {
                return _dynamicallyConfigured;
            }
            set
            {
                _dynamicallyConfigured = value;
            }
        }

        /// <summary>
        /// The number of interrupt lines utilized by a device.
        /// </summary>
        [XmlAttribute]
        public int interruptLines
        {
            get
            {
                return _interruptLines;
            }
            set
            {
                _interruptLines = value;
            }
        }

        [XmlAttribute]
        public string manufacturerID
        {
            get
            {
                return _manufacturerID;
            }
            set
            {
                _manufacturerID = value;
            }
        }

        [XmlAttribute]
        public string modelCode
        {
            get
            {
                return _modelCode;
            }
            set
            {
                _modelCode = value;
            }
        }

        [XmlAttribute]
        public string requiredMemory
        {
            get
            {
                return _requiredMemory;
            }
            set
            {
                _requiredMemory = value;
            }
        }

        [XmlAttribute]
        public VXISlotSize slotSize
        {
            get
            {
                return _slotSize;
            }
            set
            {
                _slotSize = value;
            }
        }

        /// <summary>
        /// The weight of the module in kilograms per slot occupied.
        /// </summary>
        [XmlAttribute]
        public double slotWeight
        {
            get
            {
                return _slotWeight;
            }
            set
            {
                _slotWeight = value;
            }
        }

        /// <summary>
        /// The number of slots consumed.
        /// </summary>
        [XmlAttribute]
        public int slots
        {
            get
            {
                return _slots;
            }
            set
            {
                _slots = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(VXI));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current VXI object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an VXI object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output VXI object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out VXI obj, out Exception exception)
        {
            exception = null;
            obj = default(VXI);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out VXI obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public new static VXI Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((VXI)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static VXI Deserialize(Stream s)
        {
            return ((VXI)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current VXI object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an VXI object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output VXI object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out VXI obj, out Exception exception)
        {
            exception = null;
            obj = default(VXI);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out VXI obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public new static VXI LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// When present, the VXI/Keying child element shall identify the VXI local bus lockout key details utilized by the instrument. Keying Class 1 through 6 shall be as defined by VXI-1, B.7.2.6 [B25]. Keying Class 7 shall be defined as “no local bus,” keying class 8 shall be defined as “sensor ±16V,” and keying class 9 shall be defined as “sensor ±42V.”
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType = true, Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class VXIKeying
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int _bottomRight;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int _bottomLeft;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int _topRight;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private int _topLeft;

        private static XmlSerializer serializer;

        /// <summary>
        /// An integer representing the keying class (1 through 6) defined by the VXI-1, Figure B.28 [B25]Classes 7, 8, and 9 are defined as follows:Class 7 = No local busClass 8 = Sensor ±16 VClass 9 = Sensor ±42 VBottom key supports D size modules. Bottom key on C size modules shall be specified as 7.
        /// </summary>
        [XmlAttribute]
        public int bottomRight
        {
            get
            {
                return _bottomRight;
            }
            set
            {
                _bottomRight = value;
            }
        }

        /// <summary>
        /// An integer representing the keying class (1 through 6) defined by VXI-1, Figure B.28 [B25]Classes 7, 8, and 9 are defined as follows:Class 7 = No local busClass 8 = Sensor ±16 VClass 9 = Sensor ±42 VBottom key supports D size modules. Bottom key on C size modules shall be specified as 7.
        /// </summary>
        [XmlAttribute]
        public int bottomLeft
        {
            get
            {
                return _bottomLeft;
            }
            set
            {
                _bottomLeft = value;
            }
        }

        /// <summary>
        /// An integer representing the keying class (1 through 6) defined by VXI-1, Figure B.28 [B25]Classes 7, 8, and 9 are defined as follows:Class 7 = No local busClass 8 = Sensor ±16 VClass 9 = Sensor ±42 VTop key supports C size modules only.
        /// </summary>
        [XmlAttribute]
        public int topRight
        {
            get
            {
                return _topRight;
            }
            set
            {
                _topRight = value;
            }
        }

        /// <summary>
        /// An integer representing the keying class (1 through 6) defined by VXI-1, Figure B.28 [B25]Classes 7, 8, and 9 are defined as follows:Class 7 = No local busClass 8 = Sensor ±16 VClass 9 = Sensor ±42 VTop key supports C size modules only.
        /// </summary>
        [XmlAttribute]
        public int topLeft
        {
            get
            {
                return _topLeft;
            }
            set
            {
                _topLeft = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(VXIKeying));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current VXIKeying object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an VXIKeying object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output VXIKeying object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out VXIKeying obj, out Exception exception)
        {
            exception = null;
            obj = default(VXIKeying);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out VXIKeying obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public static VXIKeying Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((VXIKeying)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static VXIKeying Deserialize(Stream s)
        {
            return ((VXIKeying)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current VXIKeying object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an VXIKeying object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output VXIKeying object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out VXIKeying obj, out Exception exception)
        {
            exception = null;
            obj = default(VXIKeying);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out VXIKeying obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public static VXIKeying LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// When present, the VXI/ModuleCooling child element shall identify the VXI instruments air-flow and back-pressure cooling characteristics.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [DebuggerStepThrough]
    [DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType = true, Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public partial class VXIModuleCooling
    {

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _backPressure;

        [EditorBrowsable(EditorBrowsableState.Never)]
        private double _airFlow;

        private static XmlSerializer serializer;

        /// <summary>
        /// The module cooling as back pressure in mm/H2O
        /// </summary>
        [XmlAttribute]
        public double backPressure
        {
            get
            {
                return _backPressure;
            }
            set
            {
                _backPressure = value;
            }
        }

        /// <summary>
        /// Represents Module Cooling as air flow in liters/sec.
        /// </summary>
        [XmlAttribute]
        public double airFlow
        {
            get
            {
                return _airFlow;
            }
            set
            {
                _airFlow = value;
            }
        }

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(VXIModuleCooling));
                }
                return serializer;
            }
        }

        #region Serialize/Deserialize
        /// <summary>
        /// Serializes current VXIModuleCooling object into an XML string
        /// </summary>
        /// <returns>string XML value</returns>
        public virtual string Serialize()
        {
            StreamReader streamReader = null;
            MemoryStream memoryStream = null;
            try
            {
                memoryStream = new MemoryStream();
                Serializer.Serialize(memoryStream, this);
                memoryStream.Seek(0, SeekOrigin.Begin);
                streamReader = new StreamReader(memoryStream);
                return streamReader.ReadToEnd();
            }
            finally
            {
                if ((streamReader != null))
                {
                    streamReader.Dispose();
                }
                if ((memoryStream != null))
                {
                    memoryStream.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes workflow markup into an VXIModuleCooling object
        /// </summary>
        /// <param name="input">string workflow markup to deserialize</param>
        /// <param name="obj">Output VXIModuleCooling object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool Deserialize(string input, out VXIModuleCooling obj, out Exception exception)
        {
            exception = null;
            obj = default(VXIModuleCooling);
            try
            {
                obj = Deserialize(input);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool Deserialize(string input, out VXIModuleCooling obj)
        {
            Exception exception;
            return Deserialize(input, out obj, out exception);
        }

        public static VXIModuleCooling Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((VXIModuleCooling)(Serializer.Deserialize(System.Xml.XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }

        public static VXIModuleCooling Deserialize(Stream s)
        {
            return ((VXIModuleCooling)(Serializer.Deserialize(s)));
        }
        #endregion

        /// <summary>
        /// Serializes current VXIModuleCooling object into file
        /// </summary>
        /// <param name="fileName">full path of outupt xml file</param>
        /// <param name="exception">output Exception value if failed</param>
        /// <returns>true if can serialize and save into file; otherwise, false</returns>
        public virtual bool SaveToFile(string fileName, out Exception exception)
        {
            exception = null;
            try
            {
                SaveToFile(fileName);
                return true;
            }
            catch (Exception e)
            {
                exception = e;
                return false;
            }
        }

        public virtual void SaveToFile(string fileName)
        {
            StreamWriter streamWriter = null;
            try
            {
                string xmlString = Serialize();
                FileInfo xmlFile = new FileInfo(fileName);
                streamWriter = xmlFile.CreateText();
                streamWriter.WriteLine(xmlString);
                streamWriter.Close();
            }
            finally
            {
                if ((streamWriter != null))
                {
                    streamWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Deserializes xml markup from file into an VXIModuleCooling object
        /// </summary>
        /// <param name="fileName">string xml file to load and deserialize</param>
        /// <param name="obj">Output VXIModuleCooling object</param>
        /// <param name="exception">output Exception value if deserialize failed</param>
        /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
        public static bool LoadFromFile(string fileName, out VXIModuleCooling obj, out Exception exception)
        {
            exception = null;
            obj = default(VXIModuleCooling);
            try
            {
                obj = LoadFromFile(fileName);
                return true;
            }
            catch (Exception ex)
            {
                exception = ex;
                return false;
            }
        }

        public static bool LoadFromFile(string fileName, out VXIModuleCooling obj)
        {
            Exception exception;
            return LoadFromFile(fileName, out obj, out exception);
        }

        public static VXIModuleCooling LoadFromFile(string fileName)
        {
            FileStream file = null;
            StreamReader sr = null;
            try
            {
                file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                sr = new StreamReader(file);
                string xmlString = sr.ReadToEnd();
                sr.Close();
                file.Close();
                return Deserialize(xmlString);
            }
            finally
            {
                if ((file != null))
                {
                    file.Dispose();
                }
                if ((sr != null))
                {
                    sr.Dispose();
                }
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [XmlTypeAttribute(AnonymousType = true, Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public enum VXIAddressSpace
    {

        A16,

        A24,

        A32,

        A64,
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [XmlTypeAttribute(AnonymousType = true, Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public enum VXIDeviceClass
    {

        Message,

        Register,
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [XmlTypeAttribute(AnonymousType = true, Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public enum VXISlotSize
    {

        A,

        B,

        C,

        D,
    }

    /// <summary>
    /// Base type: restriction of xs:string
    /// This type shall be used as the base type of any XML schema attribute or element that is required to be nonblank. This type uses the XML &lt;xs:minLength value=”1”/&gt; specification to create a non-nullable string, i.e., a string that must contain at least one character. Also, white space will be collapsed (i.e., multiple space characters will be replaced with a single space).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.0.30319.18408")]
    [Serializable]
    [XmlTypeAttribute(AnonymousType = true, Namespace = "urn:IEEE-1671.2:2012:InstrumentDescription")]
    public enum InstrumentDescriptionType
    {

        Instrument,

        Module,

        Option,
    }
}
#pragma warning restore
